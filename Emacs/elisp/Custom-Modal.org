#+TITLE: Custom modal
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/elisp/in-custom-modal.el

This file contains the description and configuration of the productivity workflow I use with Org Mode.

* Table of Contents
:PROPERTIES:
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#ideas-and-commentaries][Ideas and commentaries]]
  - [[#idea][Idea]]
  - [[#must-do-05-0][Must do [0/5] [0%]​]]
- [[#package-heading][Package heading]]
- [[#required-packagesvariables][Required packages/variables]]
- [[#definitions][Definitions]]
- [[#with-keys][With keys]]
- [[#modal-mode][Modal mode]]
- [[#keybindings-for-the-modal][Keybindings for the modal]]
- [[#module-setup][Module Setup]]
:END:

* Ideas and commentaries
** Idea

The principal idea behind this is to create two keymaps for emacs with hight privileges.

- A 'Command' keymap. It will hold all commands features and not *really* needed features.
- A 'Editing' keymap. It will be capable of insert/edit text, jump around the buffer.

For now I'm only implementing the first one. I'm using Modalka and Evil as guide. The main difference with those are:
- TOTALLY empty maps. No default keys, nothing predefined.
  - I don't want to define ANY keybindings. Anyone has preferences and this will force to bind only the needed keys.
- For now I'm only thinking on only two modes. I don't want to be defining keys for many modes (I think nobody really want)
- Not fancy function definitions. Evil defined lots (really lots) of functions to jump, move, and move. I prefer to leave this as vanilla as posible.
** Must do [0/5] [0%]

- [ ] Create a better minor mode. (Don't use macro?)
- [ ] Delete buffer-local minor mode.
- [ ] Implements multiples keymaps? Future feature.
  Must have a solid initial map before implement this.
- [ ] Define keys.
- [ ] Hide from wich-key un-deleteable keys. (Ex: C-x 8)

* Package heading

#+begin_src emacs-lisp
;;; custom-modal.el --- Easily introduce native modal editing of your own design -*- lexical-binding: t; -*-
;;
;; Copyright © 2015–present Mark Karpov <markkarpov92@gmail.com>
;;
;; Author:
;; URL:
;; Version: 0.0.1
;; Package-Requires: ((emacs "27.1"))
;; Keywords: modal editing
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation, either version 3 of the License, or (at your
;; option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
;; Public License for more details.
;;
;; You should have received a copy of the GNU General Public License along
;; with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Create modal editing on Emacs.
;;

;;; Code:

#+end_src

* Required packages/variables
#+begin_src emacs-lisp

(require 'cl-lib)
(require 'quail)

#+end_src

* Definitions

#+begin_src emacs-lisp

(defgroup custom-modal nil
  "Introduce native modal editing of your own design"
  :group  'editing
  :tag    "Custom-Modal"
  :prefix "custom-modal-"
  :link   '(url-link :tag "GitHub" "https://github.com/NicolasIriarte"))

(defcustom custom-modal-cursor-type 'box
  "Cursor type to use in `custom-modal-mode'.

See description of `cursor-type' for mode information, this
variable should follow the same conventions."
  :tag "Cursor Type"
  :type '(choice
          (const :tag "use the cursor specified for the frame" t)
          (const :tag "don't display a cursor" nil)
          (const :tag "display a filled box cursor" box)
          (const :tag "display a hollow box cursor" hollow)
          (const :tag "display a vertical bar cursor with default width" bar)
          (cons  :tag "display a vertical bar cursor with given width"
                 (const bar) (integer :tag "width of cursor"))
          (const :tag "display a horizontal bar cursor with default height" hbar)
          (cons  :tag "display a horizontal bar cursor with given height"
                 (const hbar (integer :tag "height of cursor")))))

;;;###autoload
(defcustom custom-modal-excluded-modes nil
  "List of major modes for which `custom-modal-mode' should not be activated.

This variable is considered when Custom-Modal is enabled globally via
`global-custom-modal-mode'."
  :tag  "Excluded Modes"
  :type '(repeat :tag "Major modes to exclude" symbol))

(defvar custom-modal--default-cursor-color nil)
(defvar custom-modal-cursor-color "#ff7300"
  "Color of cursor when custom modal is enbled.
Set to nil to disable.")

(defvar custom-modal-mode-map (make-sparse-keymap)
  "This is Custom-Modal mode map, used to translate your keys.")

(defvar custom-modal--original-map nil
  "Save the global keymap to restore later.")

#+end_src

* With keys
Run command/defun with defaults keys. This is useful when we need (for example) write text for a defun on command-mode

#+begin_src emacs-lisp


(defun custom-modal-run-with-global-map (cmd)
  "Run CMD with normal Emacs keys."
  (global-custom-modal-mode -1)
  (funcall cmd))

#+end_src

* Modal mode

#+begin_src emacs-lisp

(defun custom-modal-load-empy-global-map ()
  "Initialize an empty global map."
  (use-global-map (make-sparse-keymap)))

(defun custom-modal-restore-global-map ()
  "Return to original global map."
  (use-global-map custom-modal--original-map))

;;;###autoload
(define-minor-mode custom-modal-mode
  "Toggle the `custom-modal-mode' minor mode.

With a prefix argument ARG, enable `custom-modal-mode' if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or NIL, and toggle it if ARG is
`toggle'.

This minor mode setups translation of key bindings according to
configuration created previously with `custom-modal-define-key' and
`custom-modal-define-keys'."
  nil "↑" custom-modal-mode-map
  (setq-local cursor-type
              (if custom-modal-mode
                  custom-modal-cursor-type
                (default-value 'cursor-type))))

(defun custom-modal--maybe-activate ()
  "Activate `custom-modal-mode' if current buffer is not minibuffer \
or blacklisted.

This is used by `custom-modal-global-mode'."
  (unless (or (minibufferp)
              (member major-mode custom-modal-excluded-modes))
    (custom-modal-mode 1)))

;;;###autoload
(define-globalized-minor-mode global-custom-modal-mode
  custom-modal-mode
  custom-modal--maybe-activate
  (if custom-modal-mode
      (progn
        (setq custom-modal--original-map (copy-keymap (current-global-map)))
        (custom-modal-load-empy-global-map)
        (setq custom-modal--default-cursor-color (frame-parameter nil 'cursor-color))
        (set-cursor-color custom-modal-cursor-color))
    (progn
      (custom-modal-restore-global-map)
      (set-cursor-color custom-modal--default-cursor-color))))

(defun custom-modal--input-function-advice (fnc key)
  "Call FNC with KEY as argument only when `custom-modal-mode' is disabled.

Otherwise use `list'."
  (funcall (if custom-modal-mode #'list fnc) key))

(advice-add 'quail-input-method :around #'custom-modal--input-function-advice)

#+end_src

* Keybindings for the modal
#+begin_src emacs-lisp

(global-set-key (kbd "<f12>") 'global-custom-modal-mode)
(define-key custom-modal-mode-map
  (kbd "<f12>") 'global-custom-modal-mode)

#+end_src

* Module Setup

This Org file produces a file called =org-workflow.el= which gets loaded up in =Init.org=; export it as a feature so that it can be loaded with =require=.

#+begin_src emacs-lisp

(provide 'in-custom-modal)

#+end_src
