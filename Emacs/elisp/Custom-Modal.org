#+TITLE: Custom modal
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/elisp/in-custom-modal.el

This file contains the description and configuration of the productivity workflow I use with Org Mode.

* Table of Contents
:PROPERTIES:
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#ideas-and-commentaries][Ideas and commentaries]]
  - [[#idea][Idea]]
  - [[#must-do-35-60][Must do [3/5] [60%]​]]
- [[#package-heading][Package heading]]
- [[#required-packagesvariables][Required packages/variables]]
- [[#definitions][Definitions]]
  - [[#mode][Mode]]
  - [[#cursor-type][Cursor type]]
  - [[#cursor-color][Cursor color]]
  - [[#keymaps][Keymaps]]
  - [[#states][States]]
- [[#defuns][Defuns]]
  - [[#mode-startend][Mode start/end]]
  - [[#cursor][Cursor]]
  - [[#maps][Maps]]
  - [[#setup-states][Setup states]]
  - [[#keybinding-definition][Keybinding definition]]
- [[#keybindings][Keybindings]]
  - [[#shared-map-generic-keys][Shared map (Generic keys)]]
  - [[#command-map][Command map]]
  - [[#editing-map][Editing map]]
- [[#module-setup][Module Setup]]
:END:

* Ideas and commentaries
** Idea

The principal idea behind this is to create two keymaps for emacs with hight privileges.

- A 'Command' keymap. It will hold all commands features and not *really* needed features.
- A 'Editing' keymap. It will be capable of insert/edit text, jump around the buffer.

For now I'm only implementing the first one. I'm using Modalka and Evil as guide. The main difference with those are:
- TOTALLY empty maps. No default keys, nothing predefined.
  - I don't want to define ANY keybindings. Anyone has preferences and this will force to bind only the needed keys.
- For now I'm only thinking on only two modes. I don't want to be defining keys for many modes (I think nobody really want)
- Not fancy function definitions. Evil defined lots (really lots) of functions to jump, move, and move. I prefer to leave this as vanilla as posible.
** Must do [3/5] [60%]

- [X] Create a better minor mode. (Don't use macro?)
- [X] Delete buffer-local minor mode.
- [X] Implements multiples keymaps? Future feature.
  Must have a solid initial map before implement this.
- [ ] Define keys.
- [ ] Hide from wich-key un-deleteable keys. (Ex: C-x 8)

* Package heading

#+begin_src emacs-lisp
;;; cm.el --- Easily introduce native modal editing of your own design -*- lexical-binding: t; -*-
;;
;; Copyright © 2015–present Mark Karpov <markkarpov92@gmail.com>
;;
;; Author:
;; URL:
;; Version: 0.0.1
;; Package-Requires: ((emacs "27.1"))
;; Keywords: modal editing
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation, either version 3 of the License, or (at your
;; option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
;; Public License for more details.
;;
;; You should have received a copy of the GNU General Public License along
;; with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Create modal editing on Emacs.
;;

;;; Code:

#+end_src

* Required packages/variables
#+begin_src emacs-lisp

(require 'cl-lib)

#+end_src

* Definitions
** Mode

#+begin_src emacs-lisp
(defgroup cm nil
  "Introduce native modal editing of your own design"
  :group  'editing
  :tag    "Cm"
  :prefix "cm-"

  :link   '(url-link :tag "GitHub" "https://github.com/NicolasIriarte"))
#+end_src
** Cursor type

#+begin_src emacs-lisp

(defcustom cm-command-cursor-type 'box
  "Cursor type to use in `cm-mode'.

See description of `cursor-type' for mode information, this
variable should follow the same conventions."
  :tag "Cursor Type"
  :type '(choice
          (const :tag "use the cursor specified for the frame" t)
          (const :tag "don't display a cursor" nil)
          (const :tag "display a filled box cursor" box)
          (const :tag "display a hollow box cursor" hollow)
          (const :tag "display a vertical bar cursor with default width" bar)
          (cons  :tag "display a vertical bar cursor with given width"
                 (const bar) (integer :tag "width of cursor"))
          (const :tag "display a horizontal bar cursor with default height" hbar)
          (cons  :tag "display a horizontal bar cursor with given height"
                 (const hbar (integer :tag "height of cursor")))))

(defcustom cm-editing-cursor-type 'bar
  "Cursor type to use in `cm-mode'.

See description of `cursor-type' for mode information, this
variable should follow the same conventions."
  :tag "Cursor Type"
  :type '(choice
          (const :tag "use the cursor specified for the frame" t)
          (const :tag "don't display a cursor" nil)
          (const :tag "display a filled box cursor" box)
          (const :tag "display a hollow box cursor" hollow)
          (const :tag "display a vertical bar cursor with default width" bar)
          (cons  :tag "display a vertical bar cursor with given width"
                 (const bar) (integer :tag "width of cursor"))
          (const :tag "display a horizontal bar cursor with default height" hbar)
          (cons  :tag "display a horizontal bar cursor with given height"
                 (const hbar (integer :tag "height of cursor")))))

(defvar cm-default-cursor-type nil
  "Used to store default value.")

#+end_src
** Cursor color

#+begin_src emacs-lisp

(defvar cm--default-cursor-color nil
  "Used to store default value.")

(defvar cm-command-cursor-color "#ff7300"
  "Color of cursor when custom modal is enbled.
Set to nil to disable.")

(defvar cm-editing-cursor-color nil
  "Color of cursor when custom modal is enbled.
Set to nil to default color.")

#+end_src

** Keymaps

#+begin_src emacs-lisp

(defvar cm-command-map (make-sparse-keymap)
  "This is Cm mode map, used to store your keys.

It has priority over shared-map.")
(suppress-keymap cm-command-map t)

(defvar cm-editing-map (make-sparse-keymap)
  "This is Cm mode map, used to store your keys.

It has priority over shared-map.")

(defvar cm-shared-map (make-keymap)
  "Map used globally when this mode is enabled.

It has the lowest priority.")

(defvar cm--original-map nil
  "Save the global keymap to restore later.")

(defvar cm--map-alist nil
  "Store the current map alist for the emulation mode map.")
#+end_src

** States

#+begin_src emacs-lisp

(defcustom cm-default-state 'command
  "Default state to start `cm-mode'.

Possibles options listed below."
  :tag "Default state"
  :type '(choice
          (const :tag "Start on command state. Recommended." command )
          (const :tag "Start on editing state" editing)))

#+end_src
* Defuns

** Mode start/end

#+begin_src emacs-lisp

(define-minor-mode cm-mode
  "Toggle the `cm-mode' minor mode.

With a prefix argument ARG, enable `cm-mode' if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or NIL, and toggle it if ARG is
`toggle'.

This minor mode setups translation of key bindings acording to
configuration created previously with `cm-define-key' and
`cm-define-keys'."
  :lighter "↑"
;;  :keymap
  :init-value nil
  :global t

  (cm-save-restore-cursor)
  (cm-load-maps)
  (if cm-mode
      (cond ((eq cm-default-state 'command)
             (cm-command-state))
            ((eq cm-default-state 'editing)
             (cm-editing-state))
            (t (message "Error cm-default-state not recognized.")))
    (progn
      (cm-clean-emulation-mode-map-alist))))

#+end_src

** Cursor

#+begin_src emacs-lisp

(defun cm-save-restore-cursor ()
  "Save or restore the cursor depending of cm-mode."
  (if cm-mode
      (progn
        (unless cm-default-cursor-type
          (setq cm-default-cursor-type cursor-type))
        ;; more here
        (unless cm--default-cursor-color
          (setq cm--default-cursor-color (frame-parameter nil 'cursor-color)))
       (unless cm-editing-cursor-color
         (setq cm-editing-cursor-color cm--default-cursor-color))
        )
    (progn
      ;; Cursor type
      (setq-default cursor-type
                    cm-default-cursor-type)
      (setq cm-default-cursor-type nil)
      ;; Cursor color
      (set-cursor-color cm--default-cursor-color)
      (setq cm--default-cursor-color nil)
      )))

#+end_src

** Maps

#+begin_src emacs-lisp

(defun cm-load-maps ()
  "Load the corrent map depending of cm."
  (if cm-mode
      (cm-load-cm-global-map)
    (cm-restore-global-map)))

(defun cm-load-cm-global-map ()
  "Initialize an empty global map."
  (unless cm--original-map
    (setq cm--original-map (copy-keymap (current-global-map))))
  (use-global-map cm-shared-map)

  (substitute-key-definition
   'self-insert-command
   'self-insert-command
   cm-shared-map cm--original-map))

(defun cm-restore-global-map ()
  "Return to original global/local map."
  (use-global-map cm--original-map)

  (setq emulation-mode-map-alists
        (delq 'cm-editing-map emulation-mode-map-alists))

  (setq emulation-mode-map-alists
        (delq 'cm-command-map emulation-mode-map-alists))

  (setq cm--original-map nil))

(defun cm-clean-emulation-mode-map-alist ()
  "Delete cm keymaps from the emulation mode map alists."
  (setq emulation-mode-map-alists
        (delq 'cm--map-alist emulation-mode-map-alists)))

#+end_src

** Setup states

#+begin_src emacs-lisp

(defun cm-command-state ()
  "Load command state."
  (interactive)
  (set-cursor-color cm-command-cursor-color)

  (setq-default cursor-type cm-command-cursor-type)

  ;; Clean emulation map and load new ones
  (cm-clean-emulation-mode-map-alist)
  (setq cm--map-alist `((cm-mode . ,cm-command-map)))
  (add-to-list 'emulation-mode-map-alists 'cm--map-alist)

  (message "Command mode loaded..."))

(defun cm-editing-state ()
  "Load command state."
  (interactive)
  (set-cursor-color cm-editing-cursor-color)
  (setq-default cursor-type cm-editing-cursor-type)

  ;; Clean emulation map and load new ones
  (cm-clean-emulation-mode-map-alist)
  (setq cm--map-alist `((cm-mode . ,cm-editing-map)))
  (add-to-list 'emulation-mode-map-alists 'cm--map-alist)

  (message "Editing mode loaded..."))

#+end_src

** Keybinding definition

#+begin_src emacs-lisp

(defun cm-set-keys (keymap key def &rest bindings)
  "Bind KEY to DEF on KEYMAP.

It can be in the single key-definition form.
`(cm-set-key (current-global-map) \"H-f\" 'backward-char)'

Or multiples.
`(cm-set-key (current-global-map)
            \"H-f\" 'forward-char
            \"H-b\" 'backward-char
            \"H-l\" 'find-file)'"
  (while key
    (define-key keymap (kbd key) def)
    (setq key (pop bindings)
          def (pop bindings))))

#+end_src

* Keybindings
** Shared map (Generic keys)

#+begin_src emacs-lisp

(cm-set-keys cm-shared-map
             "C-a" 'move-beginning-of-line
             "C-b" 'backward-char
             "C-d" 'delete-char
             "C-e" 'move-end-of-line
             "C-f" 'forward-char
             "C-g" 'keyboard-quit
             "C-h" 'backward-delete-char
             "C-n" 'next-line
             "C-p" 'previous-line
             "C-s" 'swiper
             "C-x C-c" 'save-buffers-kill-terminal
             "M-a" 'beginning-of-buffer
             "M-b" 'backward-word
             "M-e" 'end-of-buffer
             "M-f" 'forward-word
             "M-x" 'counsel-M-x
             "<f12>" 'cm-mode
             )

#+end_src

** Command map
#+begin_src emacs-lisp

(cm-set-keys cm-command-map
             "0" 'delete-window
             "1" 'delete-other-windows
             "2" 'split-window-below
             "3" 'split-window-right
             "<escape>" 'cm-editing-state
             "<f8>" 'forward-char
             )

#+end_src

** Editing map

#+begin_src emacs-lisp

(cm-set-keys cm-editing-map
             "C-SPC" 'cm-command-state
             )

#+end_src

* Module Setup

This Org file produces a file called =org-workflow.el= which gets loaded up in =Init.org=; export it as a feature so that it can be loaded with =require=.

#+begin_src emacs-lisp

(provide 'in-custom-modal)

#+end_src
